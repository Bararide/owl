#define FUSE_USE_VERSION 31
#include "tiny_ptr.hpp"
#include <chrono>
#include <cstring>
#include <fcntl.h>
#include <fstream>
#include <fuse3/fuse.h>
#include <map>
#include <set>
#include <stdexcept>
#include <string>
#include <sys/mman.h>
#include <unistd.h>
#include <unordered_map>
#include <vector>

std::ofstream perf_log("fs_perf_grok_2.log");

#define MEASURE_TIME(operation)                                                \
  auto start = std::chrono::high_resolution_clock::now();                      \
  operation;                                                                   \
  auto end = std::chrono::high_resolution_clock::now();                        \
  auto duration =                                                              \
      std::chrono::duration_cast<std::chrono::nanoseconds>(end - start);       \
  perf_log << __FUNCTION__ << ": " << duration.count() << " ns" << std::endl;

struct alignas(32) Metadata {
  mode_t mode;
  size_t size;
  uid_t uid;
  gid_t gid;
  time_t access_time;
  time_t modification_time;
  time_t create_time;
};
static_assert(std::is_trivially_copyable<Metadata>::value,
              "Metadata must be trivially copyable");

struct PathCacheEntry {
  uint32_t id;
  char path[256];
};

constexpr size_t PATH_CACHE_SIZE = 128;
std::vector<PathCacheEntry> path_cache(PATH_CACHE_SIZE);
std::atomic<size_t> path_cache_index{0};

template <typename T> inline void prefetch(const T *addr) {
  __builtin_prefetch(addr, 0, 3);
}

tp::wrapper::TinyPtrTable<Metadata> *metadata_table = nullptr;
std::unordered_map<uint32_t, std::unordered_map<std::string, uint32_t>>
    dir_children;
std::unordered_map<uint32_t, std::string> file_contents;
uint32_t next_id = 1;
const uint32_t root_id = 0;

uint32_t hash_path(const char *path) {
  uint32_t hash = 5381;
  int c;
  while ((c = *path++))
    hash = ((hash << 5) + hash) + c;
  return hash;
}

uint32_t find_in_path_cache(const char *path) {
  uint32_t path_hash = hash_path(path);
  for (size_t i = 0; i < PATH_CACHE_SIZE; ++i) {
    if (path_cache[i].id != 0 && strcmp(path_cache[i].path, path) == 0) {
      return path_cache[i].id;
    }
  }
  return static_cast<uint32_t>(-1);
}

void add_to_path_cache(const char *path, uint32_t id) {
  size_t idx = path_cache_index.fetch_add(1) % PATH_CACHE_SIZE;
  strncpy(path_cache[idx].path, path, 255);
  path_cache[idx].path[255] = '\0';
  path_cache[idx].id = id;
}

uint32_t find_node_id(const char *path) {
  uint32_t cached_id = find_in_path_cache(path);
  if (cached_id != static_cast<uint32_t>(-1)) {
    return cached_id;
  }

  std::string p = path;
  if (p == "/") {
    return root_id;
  }
  if (p.empty() || p[0] != '/') {
    return static_cast<uint32_t>(-1);
  }

  std::vector<std::string_view> parts;
  parts.reserve(8);

  size_t pos = 1;
  size_t start = pos;
  while (pos < p.size()) {
    if (p[pos] == '/') {
      if (pos > start) {
        parts.emplace_back(p.data() + start, pos - start);
      }
      start = pos + 1;
    }
    pos++;
  }
  if (start < p.size()) {
    parts.emplace_back(p.data() + start, p.size() - start);
  }

  uint32_t current = root_id;
  for (const auto &part : parts) {
    auto dit = dir_children.find(current);
    if (dit == dir_children.end()) {
      return static_cast<uint32_t>(-1);
    }

    std::string part_str(part);
    auto cit = dit->second.find(part_str);
    if (cit == dit->second.end()) {
      return static_cast<uint32_t>(-1);
    }
    current = cit->second;

    int tp = metadata_table->get_tiny_ptr(current);
    if (tp >= 0) {
      const Metadata &meta = metadata_table->dereference(current, tp);
      prefetch(&meta);
    }
  }

  add_to_path_cache(path, current);
  return current;
}

std::pair<uint32_t, std::string> get_parent_and_base(const char *path) {
  std::string p = path;
  if (p == "/") {
    return {static_cast<uint32_t>(-1), ""};
  }

  size_t last = p.rfind('/');
  std::string base;
  std::string parent_p;

  if (last == 0) {
    parent_p = "/";
    base = p.substr(1);
  } else if (last == std::string::npos) {
    parent_p = "/";
    base = p;
  } else {
    parent_p = p.substr(0, last);
    base = p.substr(last + 1);
  }

  if (parent_p.empty()) {
    parent_p = "/";
  }

  uint32_t parent_id = find_in_path_cache(parent_p.c_str());
  if (parent_id == static_cast<uint32_t>(-1)) {
    parent_id = find_node_id(parent_p.c_str());
  }

  return {parent_id, base};
}

static int getattr_callback(const char *path, struct stat *stbuf,
                            struct fuse_file_info *) {
  MEASURE_TIME(memset(stbuf, 0, sizeof(struct stat));

  uint32_t id = find_node_id(path);
  if (id == static_cast<uint32_t>(-1)) {
    return -ENOENT;
  }

  int tp = metadata_table->get_tiny_ptr(id);
  if (tp < 0) {
    return -ENOENT;
  }

  Metadata meta = metadata_table->dereference(id, tp);

  stbuf->st_mode = meta.mode;
  stbuf->st_uid = meta.uid;
  stbuf->st_gid = meta.gid;
  stbuf->st_atime = meta.access_time;
  stbuf->st_mtime = meta.modification_time;
  stbuf->st_ctime = meta.create_time;

  if ((meta.mode & S_IFDIR) != 0) {
    stbuf->st_nlink = 2;
    stbuf->st_size = 4096;
  } else {
    stbuf->st_nlink = 1;
    stbuf->st_size = meta.size;
  });

  return 0;
}

static int readdir_callback(const char *path, void *buf, fuse_fill_dir_t filler,
                            off_t, struct fuse_file_info *,
                            enum fuse_readdir_flags) {
  MEASURE_TIME(
      uint32_t id = find_node_id(path);
      if (id == static_cast<uint32_t>(-1)) { return -ENOENT; }

      int tp = metadata_table->get_tiny_ptr(id);
      if (tp < 0) { return -ENOENT; }

      Metadata meta = metadata_table->dereference(id, tp);
      if ((meta.mode & S_IFDIR) == 0) { return -ENOTDIR; }

      filler(buf, ".", nullptr, 0, FUSE_FILL_DIR_PLUS);
      filler(buf, "..", nullptr, 0, FUSE_FILL_DIR_PLUS);

      auto it = dir_children.find(id); if (it != dir_children.end()) {
        for (const auto &child : it->second) {
          filler(buf, child.first.c_str(), nullptr, 0, FUSE_FILL_DIR_PLUS);
        }
      });

  return 0;
}

static int rmdir_callback(const char *path) {
  auto [parent_id, base] = get_parent_and_base(path);
  if (parent_id == static_cast<uint32_t>(-1)) {
    return -ENOENT;
  }
  if (base.empty()) {
    return -EINVAL;
  }

  auto &children = dir_children[parent_id];
  auto it = children.find(base);
  if (it == children.end()) {
    return -ENOENT;
  }

  uint32_t id = it->second;
  int tp = metadata_table->get_tiny_ptr(id);
  if (tp < 0) {
    return -ENOENT;
  }

  Metadata meta = metadata_table->dereference(id, tp);
  if ((meta.mode & S_IFDIR) == 0) {
    return -ENOTDIR;
  }

  if (!dir_children[id].empty()) {
    return -ENOTEMPTY;
  }

  children.erase(it);
  dir_children.erase(id);
  metadata_table->free(id);

  return 0;
}

static int mkdir_callback(const char *path, mode_t mode) {
  time_t now = time(nullptr);
  auto [parent_id, base] = get_parent_and_base(path);
  if (parent_id == static_cast<uint32_t>(-1)) {
    return -ENOENT;
  }
  if (base.empty()) {
    return -EINVAL;
  }

  int tp = metadata_table->get_tiny_ptr(parent_id);
  if (tp < 0) {
    return -ENOENT;
  }

  Metadata pmeta = metadata_table->dereference(parent_id, tp);
  if ((pmeta.mode & S_IFDIR) == 0) {
    return -ENOTDIR;
  }

  if (dir_children[parent_id].count(base) > 0) {
    return -EEXIST;
  }

  uint32_t new_id = next_id++;
  Metadata new_meta{};
  new_meta.mode = S_IFDIR | (mode & 07777);
  new_meta.size = 0;
  new_meta.uid = getuid();
  new_meta.gid = getgid();
  new_meta.access_time = now;
  new_meta.modification_time = now;
  new_meta.create_time = now;

  tp = metadata_table->allocate(new_id, new_meta);
  while (tp < 0) {
    auto new_table =
        metadata_table->resize(metadata_table->get_requested_capacity() * 2);
    if (!new_table) {
      return -ENOMEM;
    }
    delete metadata_table;
    metadata_table = new_table;
    tp = metadata_table->allocate(new_id, new_meta);
  }

  dir_children[parent_id][base] = new_id;
  dir_children[new_id];

  std::string full_path(path);
  add_to_path_cache(full_path.c_str(), new_id);

  return 0;
}

static int open_callback(const char *path, struct fuse_file_info *fi) {
  uint32_t id = find_node_id(path);
  if (id == static_cast<uint32_t>(-1)) {
    return -ENOENT;
  }

  int tp = metadata_table->get_tiny_ptr(id);
  if (tp < 0) {
    return -ENOENT;
  }

  Metadata meta = metadata_table->dereference(id, tp);
  if ((meta.mode & S_IFREG) == 0) {
    return -EISDIR;
  }

  return 0;
}

static int read_callback(const char *path, char *buf, size_t size, off_t offset,
                         struct fuse_file_info *) {
  uint32_t id = find_node_id(path);
  if (id == static_cast<uint32_t>(-1)) {
    return -ENOENT;
  }

  int tp = metadata_table->get_tiny_ptr(id);
  if (tp < 0) {
    return -ENOENT;
  }

  Metadata meta = metadata_table->dereference(id, tp);
  if ((meta.mode & S_IFREG) == 0) {
    return -EISDIR;
  }

  auto it = file_contents.find(id);
  if (it == file_contents.end()) {
    return -EIO;
  }

  const std::string &content = it->second;
  if (offset >= static_cast<off_t>(content.size())) {
    return 0;
  }

  size_t len = std::min(content.size() - offset, size);
  memcpy(buf, content.c_str() + offset, len);

  return static_cast<int>(len);
}

static int create_callback(const char *path, mode_t mode,
                           struct fuse_file_info *) {
  time_t now = time(nullptr);
  auto [parent_id, base] = get_parent_and_base(path);
  if (parent_id == static_cast<uint32_t>(-1)) {
    return -ENOENT;
  }
  if (base.empty()) {
    return -EINVAL;
  }

  int tp = metadata_table->get_tiny_ptr(parent_id);
  if (tp < 0) {
    return -ENOENT;
  }

  Metadata pmeta = metadata_table->dereference(parent_id, tp);
  if ((pmeta.mode & S_IFDIR) == 0) {
    return -ENOTDIR;
  }

  if (dir_children[parent_id].count(base) > 0) {
    return -EEXIST;
  }

  uint32_t new_id = next_id++;
  Metadata new_meta{};
  new_meta.mode = S_IFREG | (mode & 07777);
  new_meta.size = 0;
  new_meta.uid = getuid();
  new_meta.gid = getgid();
  new_meta.access_time = now;
  new_meta.modification_time = now;
  new_meta.create_time = now;

  tp = metadata_table->allocate(new_id, new_meta);
  while (tp < 0) {
    auto new_table =
        metadata_table->resize(metadata_table->get_requested_capacity() * 2);
    if (!new_table) {
      return -ENOMEM;
    }
    delete metadata_table;
    metadata_table = new_table;
    tp = metadata_table->allocate(new_id, new_meta);
  }

  dir_children[parent_id][base] = new_id;
  file_contents[new_id] = "";

  std::string full_path(path);
  add_to_path_cache(full_path.c_str(), new_id);

  return 0;
}

static int utimens_callback(const char *path, const struct timespec tv[2],
                            struct fuse_file_info *fi) {
  uint32_t id = find_node_id(path);
  if (id == static_cast<uint32_t>(-1)) {
    return -ENOENT;
  }

  int tp = metadata_table->get_tiny_ptr(id);
  if (tp < 0) {
    return -ENOENT;
  }

  Metadata meta = metadata_table->dereference(id, tp);
  meta.access_time = tv[0].tv_sec;
  meta.modification_time = tv[1].tv_sec;

  metadata_table->set(id, meta);

  return 0;
}

static int write_callback(const char *path, const char *buf, size_t size,
                          off_t offset, struct fuse_file_info *fi) {
  uint32_t id = find_node_id(path);
  if (id == static_cast<uint32_t>(-1)) {
    return -ENOENT;
  }

  int tp = metadata_table->get_tiny_ptr(id);
  if (tp < 0) {
    return -ENOENT;
  }

  Metadata meta = metadata_table->dereference(id, tp);
  if ((meta.mode & S_IFREG) == 0) {
    return -EISDIR;
  }

  if ((meta.mode & S_IWUSR) == 0) {
    return -EACCES;
  }

  auto it = file_contents.find(id);
  if (it == file_contents.end()) {
    return -EIO;
  }

  std::string &content = it->second;
  if (offset + size > static_cast<off_t>(content.size())) {
    content.resize(offset + size);
  }

  memcpy(&content[offset], buf, size);

  time_t now = time(nullptr);
  meta.size = content.size();
  meta.modification_time = now;
  meta.access_time = now;

  metadata_table->set(id, meta);

  return static_cast<int>(size);
}

static int unlink_callback(const char *path) {
  auto [parent_id, base] = get_parent_and_base(path);
  if (parent_id == static_cast<uint32_t>(-1)) {
    return -ENOENT;
  }
  if (base.empty()) {
    return -EINVAL;
  }

  auto &children = dir_children[parent_id];
  auto it = children.find(base);
  if (it == children.end()) {
    return -ENOENT;
  }

  uint32_t id = it->second;
  int tp = metadata_table->get_tiny_ptr(id);
  if (tp < 0) {
    return -ENOENT;
  }

  Metadata meta = metadata_table->dereference(id, tp);
  if ((meta.mode & S_IFREG) == 0) {
    return -EISDIR;
  }

  children.erase(it);
  file_contents.erase(id);
  metadata_table->free(id);

  return 0;
}

static struct fuse_operations ops = {.getattr = getattr_callback,
                                     .readdir = readdir_callback,
                                     .open = open_callback,
                                     .read = read_callback,
                                     .write = write_callback,
                                     .mkdir = mkdir_callback,
                                     .create = create_callback,
                                     .utimens = utimens_callback,
                                     .rmdir = rmdir_callback,
                                     .unlink = unlink_callback};

int main(int argc, char *argv[]) {
  for (auto &entry : path_cache) {
    entry.id = 0;
    entry.path[0] = '\0';
  }

  if (mlockall(MCL_CURRENT | MCL_FUTURE) != 0) {
    perf_log << "Warning: mlockall failed: " << strerror(errno) << std::endl;
  }

  time_t now = time(nullptr);
  Metadata root_meta{};
  root_meta.mode = S_IFDIR | 0755;
  root_meta.size = 0;
  root_meta.uid = getuid();
  root_meta.gid = getgid();
  root_meta.access_time = now;
  root_meta.modification_time = now;
  root_meta.create_time = now;

  metadata_table = new tp::wrapper::TinyPtrTable<Metadata>(1024, 0.9);
  int tp = metadata_table->allocate(root_id, root_meta);
  if (tp < 0) {
    perf_log << "FAILED: Initial allocation failed" << std::endl;
    delete metadata_table;
    return 1;
  }

  add_to_path_cache("/", root_id);
  dir_children[root_id];

  int ret = fuse_main(argc, argv, &ops, nullptr);

  delete metadata_table;
  perf_log << "END" << std::endl;
  return ret;
}